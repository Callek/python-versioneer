# -*- org -*-

* github tarballs
** when downloaded from the "tags" page, look like:
     warner-python-ed25519-0.4-0-gdeb78a0.tar.gz
** and unpack into:
     warner-python-ed25519-deb78a0/
** That's a bummer, I was hoping they'd be like "python-ed25519-0.4.tar.gz"
   and unpack into python-ed25519-0.4/ .

* git attributes --help:
 add .gitattributes, with "_version.py export-subst"
 then put $Format:XXX$ in the file, with XXX from git-log's --pretty=format:
  $Format:%H$ -> commit hash
   %h -> abbreviated commit hash
   %d -> ref names, like git log --decorate
 also "filename export-ignore": won't be added to an archive

 might be possible to get github's 'git archive' to put the tag name into a
 _version.py file

* first attempt at a plan:
** in the source tree
   - commit a _version.py with a s="$Format:%d$" and some massaging code
   - need to parse, strip boring refs, return highest non-boring one
** when using archive from github
   - __init__.py pulls massaged string from _version.py
** when building from checkout for testing
   - 'setup.py build' does git-describe and replaces _version.py with a
     one-line variable set
   - trouble: modifying a committed file, VCS will complain
     - avoid by subclassing 'build', only modify build/lib../../_version.py
** when building sdist from checkout
   - 'setup.py sdist' does git-describe and replaces _version.py
   - less trouble with modifying a committed file, if we always do sdist from
     a clean checkout (which is probably a good idea anyways)
** when running from source from checkout
   - ?? need to do git-describe from _version.py, eww

** problems:
*** modifying _version.py during 'setup.py build' (for testing), leaves tree
    in modified state, and you don't want to accidentally replace that
    _version.py
*** really we want to modify a file in build/, not in the source tree
    - might be possible for 'setup.py build', since we can get control after
      the superclass method has run
      - 'setup.py build' uses distutils.command.build_py
        build_py.build_module to copy things into the build directory, can
        use to figure out the _version.py to modify. Check for hardlinks. Hm,
        looks like build doesn't use hardlinks, although sdist does.
    - probably not so possible for 'setup.py sdist'. But maybe that's ok.
      - actually, cmd.sub_commands=[] is a list of (name,runp) that are
        invoked after self.filelist is created (but not populated), could be
        used to invoke extra commands
      - self.make_release_tree() is what creates the tree that will be
        archived.. could override that, modify _version.py on the way out
        - good to know: make_release_tree() creates hardlinks if possible. If
          'setup.py build' does this too, that would explain why it's not
          always necessary to rebuild when source files are changed.
        - need to ensure _version.py is not a link before changing it
        - make_release_tree(base_dir, files) creates os.path.join(base_dir,f)
          for f in files
**** let's investigate this:
     - 'setup.py build' runs superclass, looks for .git, if present:
       - use git-describe
       - locate build/STUFF/../_version.py
       - replace it with one-line string variable set
     - if no .git, assume the version number is already good, leave it alone
     - 'setup.py sdist' looks for .git first, modifies _version.py in source
       tree, then runs superclass

*** could modify a different file, one which is in .gitignore
    - _version.py will need to import that
*** setup.py build 

* current problems
** DONE running 'setup.py build' from a git-archive tree
   - need version_from_expanded_variable() in versioneer.py too, not just
     _version.py

* Supported Upstream Versions
** setuptools
*** 33.1.1 - py2.6,2.7 .. 3.3 -> 3.6, pypy
*** 36.2.4 ->  + pypy3 [@latest=5.4] [@python=>3.5.3]
*** 37.0.0 -> remove py2.6
*** 39.2.0 -> remove py3.3
*** 40.5.0 -> + py3.7
*** 40.9.0 ->  pypy2 ==> pypy2.7-6.0
*** 41.0.1 ->  pypy3 ==> pypy3.5-6.0
*** 41.1.0 -> pypy2.7-6.0 ==> pypy, pypy3.5-6.0 ==> pypy3
*** 41.5.0 -> + py3.8 <!--versioneer is here -->
*** 44.0.0 -> - py3.4
*** 45.0.0 -> -py2.7, -pypy
*** 50.3.2 -> +py3.9
*** 51.0.0 -> -py3.5
*** 58.4.0 -> +py3.10
*** 59.7.0 -> -py3.6,  pypy3 ==> pypy-3.7
*** 62.4.0 -> py3.11{dev} (auto selects released ver when ready)
*** 65.4.1 -> -pypy-3.7, +pypy-3.19
*** 65.7.0 -> py3.12{dev} (auto selects released ver when ready)
*** 68.1.0 -> -py3.7
** Python Shipped Setuptools
*** <last checked Dec 27-2023>
*** 41.2.0 -> shipped in py3.8 {beta4}
*** 47.1.0 -> shipped in py3.8.4
           -> shipped in py3.9 {beta4}
*** 49.2.1 -> shipped in py3.8.6
           -> shipped in py3.9.0
*** 56.0.0 -> shipped in py3.8.10
           -> shipped in py3.9.5
           -> shipped in py3.10.0 {beta1}
*** 57.4.0 -> shipped in py3.9.7
           -> shipped in py3.10 {rc2}
*** 58.1.0 -> shipped in py3.9.8
           -> shipped in py3.10.1
*** 63.2.0 -> shipped in py3.10.6
*** 65.5.0 -> shipped in py3.10.9
           -> shipped in py3.11.0
*** --- -> no setuptools in bundle in py3.12
*** <last checked 69.0.3>
** cx_Freeze
*** <https://cx-freeze.readthedocs.io/en/latest/versions.html>
*** 5.1.1 -> py2.7 (no longer supported)
*** 6.0 -> py3.5 to 3.7 (no longer supported)
*** 6.1 to 6.3 -> py3.5 to py3.8 (no longer supported)
*** 6.4 to 6.8 -> py3.6 to py3.9 (no longer supported)
*** 6.9 to 6.13 -> py3.6 to py3.10 (supported)
*** 6.14 and 6.15 -> py3.7 to py3.11 (supported)
*** 6.16 -> py 3.8 to py3.12 (supported)
*** <last checked 6.15.12>
** py2exe
*** <https://github.com/py2exe/py2exe>
*** 0.10.0.2 -> py3.5 to py3.8
*** 0.10.1.0 -> +py3.9, -py3.5
*** 0.11.0.0 -> +py3.10
*** 0.11.1.0 -> -py3.6
*** 0.12.0.0 -> deprecate setup.py/distutils.setup and add "Introduce the new py2exe.freeze API"
*** 0.13.0.0 -> +py3.11, -py3.7, "Remove build_exe command line interface."
    "Note: contrary to what was announced in 0.12.x, this release does not remove the setup.py py2exe interface"
*** <last checked 0.13.0.1>
